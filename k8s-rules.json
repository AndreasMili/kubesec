{
  "rules": [
    {
      "selector": "containers[] .securityContext .capabilities .drop",
      "title": "securityContext capabilities",
      "reason": "Reducing kernel capabilities available to a container limits its attack surface",
      "points": 1,
      "href": "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
      "advise": 10
    },
    {
      "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")",
      "reason": "Drop all capabilities and add only those required to reduce syscall attack surface",
      "points": 1,
      "href": null,
      "advise": 4
    },
    {
      "selector": "containers[] .securityContext .runAsNonRoot == true",
      "reason": "Force the running image to run as a non-root user to ensure least privilege",
      "points": 1,
      "href": null,
      "advise": 10
    },
    {
      "selector": "containers[] .securityContext .runAsUser > 10000",
      "reason": "Run as a high-UID user to avoid conflicts with the host's user table",
      "points": 1,
      "href": null,
      "advise": 4
    },
    {
      "selector": "containers[] .securityContext .readOnlyRootFilesystem == true",
      "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost",
      "points": 1,
      "href": null,
      "advise": 5
    },
    {
      "selector": "containers[] .resources .limits .cpu",
      "reason": "Enforcing CPU limits prevents DOS via resource exhaustion",
      "points": 1,
      "href": null,
      "advise": 3
    },
    {
      "selector": "containers[] .resources .limits .memory",
      "reason": "Enforcing memory limits prevents DOS via resource exhaustion",
      "points": 1,
      "href": null,
      "advise": 3
    },
    {
      "selector": "containers[] .resources .requests .cpu",
      "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster",
      "points": 1,
      "href": null,
      "advise": 2
    },
    {
      "selector": "containers[] .resources .requests .memory",
      "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster",
      "points": 1,
      "href": null,
      "advise": 2
    },
    {
      "selector": ".spec .volumeClaimTemplates[] .spec .accessModes | index(\"ReadWriteOnce\")",
      "reason": null,
      "points": 1,
      "href": null,
      "kind": "StatefulSet",
      "weight": 0,
      "advise": 10
    },
    {
      "selector": ".spec .volumeClaimTemplates[] .spec .resources .requests .storage",
      "reason": null,
      "points": 1,
      "href": null,
      "kind": "StatefulSet",
      "weight": 0,
      "advise": 2
    },
    {
      "selector": "containers[] .securityContext .capabilities .add | index(\"SYS_ADMIN\")",
      "reason": "CAP_SYS_ADMIN is the most privileged capability and should always be avoided",
      "points": -30,
      "href": null
    },
    {
      "selector": "containers[] .securityContext .privileged == true",
      "reason": "Privileged containers can allow almost completely unrestricted host access",
      "points": -30,
      "href": null
    },
    {
      "selector": ".metadata .annotations .\"seccomp.security.alpha.kubernetes.io/pod\" | index(\"unconfined\")",
      "title": ".metadata .annotations .\"seccomp.security.alpha.kubernetes.io/pod\"",
      "reason": "Seccomp profiles are unconfined by default. Add a profile to set minimum privilege and secure against unknown threats",
      "weight": 0,
      "points": -1,
      "href": null
    },

    {
      "selector": "select(.metadata .annotations .\"seccomp.security.alpha.kubernetes.io/pod\" | index(\"unconfined\") == null) | .metadata .annotations .\"seccomp.security.alpha.kubernetes.io/pod\" | length > 0",
      "title": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"",
      "reason": "Seccomp profiles set minimum privilege and secure against unknown threats",
      "points": 5,
      "weight": 0,
      "href": null
    },
    {
      "selector": "select(.metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/podName\" | index(\"unconfined\") == null) | .metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/podName\" | length > 0",
      "title": ".metadata .annotations .\"container.seccomp.security.alpha.kubernetes.io/pod\"",
      "reason": "Seccomp profiles for OpenShift set minimum privilege and secure against unknown threats",
      "points": 5,
      "weight": 0,
      "href": null
    },
    {
      "selector": ".spec .hostNetwork",
      "reason": "Sharing the host's network namespace permits processes in the pod to communicate with processes bound to the host's loopback adapter",
      "weight": 0,
      "points": -9,
      "href": null
    },
    {
      "selector": ".spec .hostPID",
      "reason": "Sharing the host's PID namespace allows visibility of processes on the host, potentially leaking information such as environment variables and configuration",
      "weight": 0,
      "points": -9,
      "href": null
    },
    {
      "selector": ".spec .hostIPC",
      "reason": "Sharing the host's IPC namespace allows container processes to communicate with processes on the host",
      "weight": 0,
      "points": -9,
      "href": null
    },
    {
      "selector": ".spec .hostAliases",
      "reason": "Managing /etc/hosts aliases can prevent Docker from modifying the file after a pod's containers have already been started",
      "weight": 0,
      "points": 0,
      "href": null
    },
    {
      "selector": ".metadata .annotations .\"container.apparmor.security.beta.kubernetes.io/nginx\"",
      "reason": "Well defined AppArmor policies may provide greater protection from unknown threats. WARNING: NOT PRODUCTION READY",
      "points": 3,
      "weight": 0,
      "href": null
    },
    {
      "selector": ".spec .volumes[] .hostPath .path == \"/var/run/docker.sock\"",
      "title": ".spec .volumes[] .hostPath .path == \"/var/run/docker.sock\"",
      "reason": "Mounting the docker.socket leaks information about other containers and can allow container breakout",
      "points": -9,
      "weight": 0,
      "href": null
    },
    {
      "selector": ".spec .serviceAccountName",
      "title": "Service Accounts",
      "reason": "Service accounts restrict Kubernetes API access and should be configured with least privilege",
      "points": 3,
      "weight": 6,
      "href": null
    }
  ]
}
