{
  "rules": [
    {
      "selector": "seLinux",
      "reason": null,
      "points": 1,
      "href": null
    },
    {
      "selector": "supplementalGroups",
      "reason": null,
      "points": 1,
      "href": null
    },
    {
      "selector": "runAsUser",
      "reason": null,
      "points": 1,
      "href": null
    },
    {
      "selector": "fsGroup",
      "reason": null,
      "points": 1,
      "href": null
    },
    {
      "selector": "allowedCapabilities",
      "reason": null,
      "points": 1,
      "href": null
    },
    {
      "selector": "containers[] .securityContext .capabilities .drop",
      "reason": "Reducing kernel capabilities available to a container limits its attack surface",
      "points": 1,
      "href": "https://kubernetes.io/docs/tasks/configure-pod-container/security-context/",
      "advise": 10
    },
    {
      "selector": "containers[] .securityContext .capabilities .drop | index(\"ALL\")",
      "reason": "Drop all capabilities and add only those required to reduce syscall attack surface",
      "points": 1,
      "href": null,
      "advise": 4
    },
    {
      "selector": "containers[] .securityContext .runAsNonRoot == true",
      "reason": "Force the running image to run as a non-root user to ensure least privilege",
      "points": 1,
      "href": null,
      "advise": 10
    },
    {
      "selector": "containers[] .securityContext .runAsUser > 10000",
      "reason": "Run as a high-UID user to avoid conflicts with the host's user table",
      "points": 1,
      "href": null,
      "advise": 4
    },
    {
      "selector": "containers[] .securityContext .readOnlyRootFilesystem == true",
      "reason": "An immutable root filesystem can prevent malicious binaries being added to PATH and increase attack cost",
      "points": 1,
      "href": null,
      "advise": 5
    },
    {
      "selector": "containers[] .resources .limits .cpu",
      "reason": "Enforcing CPU limits prevents DOS via resource exhaustion",
      "points": 1,
      "href": null,
      "advise": 3
    },
    {
      "selector": "containers[] .resources .limits .memory",
      "reason": "Enforcing memory limits prevents DOS via resource exhaustion",
      "points": 1,
      "href": null,
      "advise": 3
    },
    {
      "selector": "containers[] .resources .requests .cpu",
      "reason": "Enforcing CPU requests aids a fair balancing of resources across the cluster",
      "points": 1,
      "href": null,
      "advise": 2
    },
    {
      "selector": "containers[] .resources .requests .memory",
      "reason": "Enforcing memory requests aids a fair balancing of resources across the cluster",
      "points": 1,
      "href": null,
      "advise": 2
    },
    {
      "selector": ".spec .volumeClaimTemplates[] .spec .accessModes | index(\"ReadWriteOnce\")",
      "reason": null,
      "points": 1,
      "href": null,
      "kind": "StatefulSet",
      "advise": 10
    },
    {
      "selector": ".spec .volumeClaimTemplates[] .spec .resources .requests .storage",
      "reason": null,
      "points": 1,
      "href": null,
      "kind": "StatefulSet",
      "advise": 2
    },
    {
      "selector": "containers[] .securityContext .capabilities .add | index(\"SYS_ADMIN\")",
      "reason": "CAP_SYS_ADMIN is the most privileged capability and should always be avoided",
      "points": -30,
      "href": null
    },
    {
      "selector": "containers[] .securityContext .privileged == true",
      "reason": "Privileged containers can allow almost completely unrestricted host access",
      "points": -30,
      "href": null
    }
  ]
}
